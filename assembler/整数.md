x86
1 world =2byte
mips 
1 world =4byte


访问内存的最小地址单位是一个byte



内存里面数据的排列方式分别有大端和小端
x86 的排列模式就是小端
    
    地址
    0x100  0x101  0x102 0x103
    值和地址一一对应
    67        45         23       01       
    小对小大对大    真实的值 表示0x01234567 

大端模式
    internet 里面的Soket编成运用的就是打断模式


c语言中 (指针) 类型占的内存位宽
```
     32位                     64位
     4byte      8byte         
```                                           




整数中的带符号数和五符号数的表示

```
无符号
         二进制   0101010101111111

         w表示的是占位的长度
         xi*2^i  然后相加   i>=0  i<=(w-1)   xi表示的是二进制的位数


有符号(符号位是最高位)
        -x(w-1)*2^(w-1) +   xi*2^i  然后相加   i>=0  i<=(w-2)
                 -x(w-1)*2^(w-1)表示最前面的一位是代表的是符号位

                 -x(w-1)表示的是二进制的w-1位的值(0或1)



总结
    当一个取反的方法

    -x    取 反 x          x可正可负

    -x里面的二进制所有位数 1变成0 ，0变成1 然后+1就得到取反的值

     
     假设 -x 占位宽为8位
     a =-x xor  11111111 
    a=a+1;就等于取反的值


    在硬件层面是没有代符号和不带符号的他们都被统一表示成二进制
```




无符号数和有符号数的相互转换 

```
当有符号大于0
   转换为有符号直接转过去不做任何改变

当有符号小于0
    -1 
    转化为无符号数就是最大(2^(w)-1)
    -2   转化  max -2
    依次次类推

当无符号 为0-2^(w-1) 次方范围内的时候转化为有符号不变


当无符号2^(w-1)-2^(w)-1的范围的时候转换到有符号为
      2^(w)-1  对应的有符号-1
      
      2^(w-1)=对饮有符号 -2^(w-1)


      -2^(w-1)+0xxxxxxxxx(表示宽度1byte 就是8位)and num;

```





c语言中
```
常数 
    默认是带符号数

    如有使用无符号name后面加上U   比如0U

如果无符号和带符号混合使用哪个带符号数会被默认转换为无符号数   




在c语言中除了
    模运算
    位运算
    最好不要使用无符号数
    不能仅仅因为数是非负而使用无符号数



c语言中的陷阱
    #define DELTA sizeof(int)

    int i;

    for(i=CNT;i-DELTA>=0;i-=DELTA){

    }

    sizeof(int) 返回的是 DELTA  unsigned无符号类型
     i也会变为无符号类型

     i-DELTA  无符号类型永远都是大于等于0会造成死循环


```



无符号数相加可能数据溢出
```
写程序的时候尽量看一下数据会不会找成超过位宽，超过位宽会找成数据的溢出

UAdd(u,v)={
    u+v    u+v<2^w
    u+v-2^w   u+v>=2^w  这样就会造成溢出  u+v=2^w  得到的结果就为0   
}

例本来

11111111  1byte位宽  在加1
得到
100000000  由于位宽为8位所以只能保留8位(重最低位开始)
所以最后内存里面的数字为00000000 结果为0 
```




在程序中除法
```
完成除法需要周期数比较长？？？？


建议使用位移



unsigned  xxx( unsigned x){
    return x/8;
}


//编译器优化

x>>3



汇编代码


shrl  $3 ,%eax

shrl shelf right  $3 向右移动3为

shrl  逻辑右移
sharl 算数右移
向右移动分为
    算数位移
        补0
    逻辑位移
        需要在符号位补符号位
向左移动
    只有算数位移    






带符号数除以2的整数次幂

    若同一个类型他们的值的范围都是(2^w-1-1)那个他们都是用的算数右移

    若有符号类型,他为负数那么他右移的时候应该使用逻辑位移


    








```

